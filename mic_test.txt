// =========================================================================
// INMP441 + ESP32-S3 (WROOM1) TROUBLESHOOTING TOOLKIT
// =========================================================================
// Instructions:
// 1. Copy the code for the scenario you want to test.
// 2. Paste it into your PlatformIO main.cpp or Arduino IDE.
// 3. Update the PIN defines if yours are different.
// 4. Open Serial Monitor (115200 baud).

/*
  WIRING REMINDER (ESP32-S3 WROOM1):
  ---------------------------------
  INMP441 Pin  ->  ESP32-S3 Pin
  VDD          ->  3.3V
  GND          ->  GND
  L/R          ->  GND (Sets to Left Channel)
  SCK/BCLK     ->  GPIO 41 (Match your config)
  WS/LRC       ->  GPIO 42 (Match your config)
  SD/DATA      ->  GPIO 2  (Match your config)

  COMMON ERROR CODES:
  -  0/-32768: Floating SD pin or missing WS clock (All LOW).
  -  -1 (or 65535): 'Locked High' signal. Check if SD pin is shorted to 3.3V or if L/R is floating.
*/

// =========================================================================
// SCENARIO 1: BASIC I2S CONNECTIVITY & DRIVER TEST
// =========================================================================
// Use this to check if the ESP32 can even initialize the I2S driver.
// If this fails, there is a software/driver configuration issue.

#include <Arduino.h>
#include <driver/i2s.h>

#define I2S_MIC_SCK 41
#define I2S_MIC_WS  42
#define I2S_MIC_SD  2

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n--- SCENARIO 1: I2S INIT TEST ---");

  i2s_config_t i2s_config = {
      .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
      .sample_rate = 16000,
      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
      .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
      .communication_format = I2S_COMM_FORMAT_STAND_I2S,
      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
      .dma_buf_count = 8,
      .dma_buf_len = 1024,
      .use_apll = false
  };

  i2s_pin_config_t pin_config = {
      .bck_io_num = I2S_MIC_SCK,
      .ws_io_num = I2S_MIC_WS,
      .data_out_num = -1,
      .data_in_num = I2S_MIC_SD
  };

  esp_err_t err = i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  if (err != ESP_OK) {
    Serial.printf("I2S Driver Install FAILED: %d\n", err);
  } else {
    Serial.println("I2S Driver Install: SUCCESS");
  }

  err = i2s_set_pin(I2S_NUM_0, &pin_config);
  if (err != ESP_OK) {
    Serial.printf("I2S Pin Config FAILED: %d\n", err);
  } else {
    Serial.println("I2S Pin Config: SUCCESS");
  }
}

void loop() {
  Serial.println("System Heartbeat: OK");
  delay(5000);
}


// =========================================================================
// SCENARIO 2: SERIAL PLOTTER WAVEFORM (VISUALIZER)
// =========================================================================
// Use this with "Tools -> Serial Plotter" in Arduino IDE.
// If you see a flat line regardless of noise, the mic is likely dead or L/R is wrong.
// If you see a thick band (noise floor) that jumps when you speak, mic is working!

/*
#include <Arduino.h>
#include <driver/i2s.h>

#define I2S_MIC_SCK 41
#define I2S_MIC_WS  42
#define I2S_MIC_SD  2

void setup() {
  Serial.begin(115200);
  i2s_config_t i2s_config = {
      .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
      .sample_rate = 16000,
      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
      .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
      .communication_format = I2S_COMM_FORMAT_STAND_I2S,
      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
      .dma_buf_count = 8,
      .dma_buf_len = 1024
  };
  i2s_pin_config_t pin_config = {
      .bck_io_num = I2S_MIC_SCK,
      .ws_io_num = I2S_MIC_WS,
      .data_out_num = -1,
      .data_in_num = I2S_MIC_SD
  };
  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &pin_config);
}

void loop() {
  int32_t sample = 0;
  size_t bytes_read;
  i2s_read(I2S_NUM_0, &sample, 4, &bytes_read, portMAX_DELAY);
  
  if (bytes_read > 0) {
    // Cast to 16-bit to make it easier to see on plotter
    int16_t plotSample = (sample >> 16);
    Serial.println(plotSample);
  }
}
*/


// =========================================================================
// SCENARIO 3: NOISE FLOOR & PEAK DIAGNOSIS
// =========================================================================
// Measures Peak-to-Peak volume 10 times a second.
// Good result (Silent): Values < 100
// Good result (Speaking): Values > 2000
// Bad result (Always 0): Software issue or WS/SD wire loose.
// Bad result (Always 32767 or -32768): Electrical short or bad SCK.

/*
#include <Arduino.h>
#include <driver/i2s.h>

#define I2S_MIC_SCK 41
#define I2S_MIC_WS  42
#define I2S_MIC_SD  2

void setup() {
  Serial.begin(115200);
  i2s_config_t i2s_config = {
      .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
      .sample_rate = 16000,
      .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,
      .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
      .communication_format = I2S_COMM_FORMAT_STAND_I2S,
      .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
      .dma_buf_count = 8,
      .dma_buf_len = 1024
  };
  i2s_pin_config_t pin_config = {
      .bck_io_num = I2S_MIC_SCK,
      .ws_io_num = I2S_MIC_WS,
      .data_out_num = -1,
      .data_in_num = I2S_MIC_SD
  };
  i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_NUM_0, &pin_config);
}

void loop() {
  int32_t sample = 0;
  int16_t minVal = 32767;
  int16_t maxVal = -32768;
  size_t bytes_read;

  // Take 100 samples quickly to find range
  for(int i=0; i<100; i++) {
    i2s_read(I2S_NUM_0, &sample, 4, &bytes_read, portMAX_DELAY);
    int16_t s = (sample >> 16);
    if(s < minVal) minVal = s;
    if(s > maxVal) maxVal = s;
  }

  int32_t peakToPeak = (int32_t)maxVal - (int32_t)minVal;
  Serial.printf("Audio Level: %ld | Min: %d | Max: %d\n", peakToPeak, minVal, maxVal);
  
  if (peakToPeak == 0) Serial.println("-> ALERT: Mic signal is DEAD (Flat zero).");
  if (peakToPeak > 30000) Serial.println("-> ALERT: Signal CLIPPING (Check wiring/SCK).");
  
  delay(100);
}
*/
