@app.get("/v1/audio/stream/{convo_id}")
async def stream_audio(convo_id: int, session: Session = Depends(get_session)):
    """Streams the entire audio response in ONE SHOT to ensure header integrity."""
    convo = session.get(Conversation, convo_id)
    if not convo:
        raise HTTPException(status_code=404, detail="Conversation not found")
    
    async def audio_stream_generator():
        import asyncio
        tts = SpeechSynthesisService()
        
        # Consistent gain for MAX98357A (0.0dB = Pure Signal)
        VOL_GAIN = 0.0
        
        reply_text = convo.ai_response or ""
        if not reply_text.strip():
            print("WARNING: [Stream] Nothing to synthesize.")
            return

        print(f"DEBUG: [Stream] One-Shot Synthesis for Convo {convo_id}: {reply_text[:50]}...")
        
        try:
            # [ONE-SHOT] Synthesize the entire response at once.
            # This ensures only ONE MP3 header is sent, eliminating transition static.
            audio = await tts.synthesize_stream(reply_text, volume_gain_db=VOL_GAIN)
            
            if audio:
                print(f"DEBUG: [Stream] Synthesis complete. Delivering {len(audio)} bytes.")
                # Yield in chunks for network stability
                CHUNK_SIZE = 8192
                for i in range(0, len(audio), CHUNK_SIZE):
                    yield audio[i : i + CHUNK_SIZE]
                    await asyncio.sleep(0.01) # Yield control
            else:
                print("ERROR: [Stream] Synthesis returned NO AUDIO.")
                
        except Exception as e:
            print(f"ERROR: [Stream] Failed during one-shot synthesis: {e}")

    return StreamingResponse(audio_stream_generator(), media_type="audio/mpeg")
